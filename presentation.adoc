= Wresting with Complexity
:revealjs_theme: moon
:revealjs_slideNumber: true
:revealjs_transition: slide
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js@4
:source-highlighter: highlightjs
:highlightjs-theme: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css
:highlightjsdir: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0

++++
<style>
blockquote, .paragraph { text-align: left; }
.image { text-align: center }
</style>
++++


== What is Complexity? 

[quote, https://www.etymonline.com/word/complex]
**complex** (_adj_), 1650s: "composed of interconnected parts, formed by a combination of simple things or elements"
from _com_ - with, _together_ + _plectere_ "to wear, braid, twine, entwine".


== Why do we have it? 
=== It's an essential property
[quote, Fred Brooks, No Silver Bullet]
The complexity of software is an essential property, not an accidental one. Hence, descriptions of a software entity that abstract away its complexity often abstract away its essence.

=== The problem domain is complex
[quote, Martin Fowler, Forward to Domain-Driven Design by Eric Evans]
There are many things that make software development complex. But the heart of this complexity is the essential intricacy of the problem domain itself.

== We have it
=== Victory
image:victory.png[]

=== Red Whale
image:red-whale.png[]

== Complexity comes from two places
[cols="1,1", frame="none", grid="none", options="noheader"]
|===
| **Domain Complexity**

| **Technical Complexity**
|===

== Example: Uber
=== Domain Complexity
* Demand-based pricing
* Driver assignment
* Route optimization

=== Technical Complexity
* Real-time data processing
* Distributed systems
* Payment processing
* Mobile app development

== Example: Football Simulation Game
=== Domain Complexity
* Player attributes
* Team tactics
* Match simulation
* League simulation
* Transfer market

=== Technical Complexity
* Multiplayer
* in-game purchases
* attribute updates
* Cross-device compatibility
* Real-time updates
* Graphics

== Example: Orange
=== Domain Complexity
[source,ruby]
----
new_changes = set_rescheduled(appointment, changes) if changes.key?(:appointment_at) && over_fifteen_minutes_old?
----

[source,ruby]
----
  def dependently_collected_qc_project?
    qc? && !collect_funds_independently?
  end

  def collect_funds_independently? # rubocop:todo Metrics/CyclomaticComplexity
    payment_type == PAYMENT_TYPE_CASH ||
      (parent_project.blank? && qc_project.blank?) ||
      (og? && ((qc_project.payment_type == PAYMENT_TYPE_CASH) || qc_project.cancelled?)) ||
      (qc? && parent_project.payment_type == PAYMENT_TYPE_CASH)
  end
----

image:victory_diagrams.png[]

=== Technical Complexity
* Broadcasts
* Notifications
* Integrations (Active Prospect, Optimoroute, Quickbooks, Workday, Twilio)
* off-loading background report generation
* SQL optimization

== These complexities are unavoidable

== The Hidden Complexity
Combining the growing complexity of the domain and the complexity of the technical solution.

image:brent.gif[]

== My Mission
To try to tame the beasts of complexity by keeping the domain and technical complexities separate. Relatedly, I've been haunted by this tweet, for forty days and forty nights.

image:tweet.png[]


== Introducing: Dragon Drip
_Dragon Drip_ is a small-batch coffee roaster that sources raw coffee beans and sells roasted blends online.

I identified 12 _flows_ to get a first 'end-to-end slice' through the business.

=== Add Bean
Adds a new bean to the inventory

=== Add Purchase Order
Adds a new purchase order to the system

=== Receive Purchase Order
* Mark purchase order as received
* Update inventory with the received beans

=== Add Roast Type
Adds a new roast type to the system (e.g. French roast)

===  Add Product
* Adds a new product to the system for sale on the shop
* is associated with a mix of beans, and a roast type
* Has a price
* Availibility is determined directly by stock level in the inventory.

=== Add to Basket
* Adds a product to the basket in the shop
* Max basket weight can be 10kg
* Orders over $50 are free shipping

=== Place order
* Represents a customer placing an order
* Order is set to be prepared (roasting is more or less on demand)

=== Processing orders
* Not really a user flow, but would be if we didn't do it in our domain
* We demand the amount of roasted beans required for all orders in the batch that need to be shipped today 
* For each order this could be a combination of roasts types and amounts of a certain bean across many order items
* Across all order items in the batch, we generate a series of demands
* Beans are roasted in multiples of 1kg, but sold in quantities of 250g, so there's a mix of roasted and unroasted coffee around, with different use-by dates

=== Roast Beans
* Beans can only be roasted in minimum 1kg batches
* Starts the use by date countdown
* Roasts are now ready to be allocated to orders

=== Packing order items
* Preparing the coffee blends and putting them in bags

=== Ship
* Orders are packed themselves when the each order item has been packed, and then shipped.

== Design it Twice
[quote, John Ousterhout, A Philosophy of Software Design]
Designing software is hard, so it's unlikely that your first thoughts about how to structure a module or system will produce the best design. You'll end up with a much better result if you consider multiple options for each major design decision: **design it twice**.


== 1. Domain Driven Design
My first attempt was Domain-driven design (DDD). In Domain-driven design the domain is the heart of the software, and everything else revolves around it.

=== Domain model
In DDD a series of types of object are defined that represent the real world domain. High attention is paid to a 'ubiquitous language' between the domain experts (client) and the developers. e.g. if they call it an 'SDR', we call it an 'SDR' in the code. 

=== Layered architecture

[source]
----

  +-----------------+    │
  |  Presentation   |    │
  +-----------------+    │
  |  Application    |    │
  +-----------------+    │ Dependency Direction
  |  Domain         |    │
  +-----------------+    │
  |  Infrastructure |    │
  +-----------------+    ▼

----

== Positives

=== Identifying different types of objects

There's a difference between an `Entity`, where you care about the thing's _identity_ (e.g. an Order), and a `Value Object`, where you care about the thing's _value_ (e.g. an Address). It takes a while, but thinking about the objects not *automatically* as an ActiveRecord is a good exercise.

=== Separation of Concerns

The Domain never knows what application it's being run in, so it can never think about it. It does know that it has *some* kind of persistence mechanism, but it doesn't know what it is - (it's injected in).

=== The Domain is where *everything happens*
So much so that I was able to put a Sinatra app and a CLI app over the same domain, and they just handled the user's flow, not the decisions that were being made.

- In the CLI app, an in memory database was used
- In the Sinatra app, a CSV was used as the database
- The Domain still doesn't know any of those things exist. 

=== Layered takeaway for our Rails apps
With broadcasting we actually violate the 'layered architecture' flow in a very interesting way. The Application Layer, sometimes all the way down to our 'domain' layer, knows about HTML.

[source, ruby]
----
class Projects::Update
  def maybe_broadcast_to_live_finance
    return unless project.status.in? LIVE_FINANCE_STATUSES

    Projects::LiveFinance.add(project) if project.saved_change_to_status? && project.live_financing?

    #  We know if the HTML is already on the page or not
    Projects::LiveFinance.replace(project)
  end
end
----

=== Testing
+ Domain tests are fast (there's no database)

== Negatives

=== You always go all the way through the stack on every action.

[source]
----
                           ▲
  +-----------------+    │ │
  |  Presentation   |    │ │
  +-----------------+    │ │
  |  Application    |    │ │
  +-----------------+    │ │
  |  Domain         |    │ │
  +-----------------+    │ │
  |  Infrastructure |    │ │
  +-----------------+    ▼ 

----

=== It's not really as separated as it seems

[source]
----

      ┌──┐      ┌───────────┐       ┌──────┐        ┌────────────┐       ┌──────┐     ┌───┐    ┌──┐
────► │UI├───►  │Application│ --->  │Domain│─────►  │Persistence │ ────► │Domain│ --> │App│--> │UI│
      └──┘      └───────────┘       └──────┘        └────────────┘       └──────┘     └───┘    └──┘

----

=== Testing

Because everything is so isolated, it's all mocks and stubs.

```
OrderRepository
  #find_by_id
    when the persistence layer returns a order
      behaves like a successful result
    when the persistence layer raises an exception
      behaves like a failure result
  #save
    calls the save on the persistence layer with the order
    behaves like a successful result
  #all
    behaves like a successful result
```

=== Repositories
They're fine, but, I still ended up thinking very CRUDily.

=== Writing it all out by hand
When it comes to writing `#save`, `#find` etc, Rails gives me a lot for free. I'm used to it. 

== 2. 'Functional Core, Imperative Shell'

Push the I/O to the edges, and keep the *decision making* in a core that is pure and functional.

The edges are larger than in DDD - they handle the Technical Complexity. The core is as complex as your Domain.

[source]
----
 ┌───┐      ┌────────────────────────────────┐       ┌───┐
 │I/O│────► │Business Logic / Decision Making│─────► │I/O│
 └───┘      └────────────────────────────────┘       └───┘
----

== An example

=== What does this code return?

[source, ruby]
----
@product.save
----

=== Boolean. What else?

[source, ruby]
----
@product.save # => Boolean
----

=== What else?

[source, ruby]
----
@product.save # => [Boolean, @product*] (@product has also changed)
----

=== Holy S#!t
[source, ruby]
----
@product.save # => [Boolean, @product*,
              #              AdapterNotFound,
              #              AdapterNotSpecified,
              #              AttributeAssignmentError,
              #              ConnectionError,
              #              ConnectionFailed,
              #              ConnectionTimeoutError,
              #              Deadlocked,
              #              InvalidForeignKey,
              #              LockWaitTimeout,
              #              QueryCanceled,
              #              ReadOnlyRecord,
              #              RecordInvalid,
              #              RecordNotDestroyed,
              #              RecordNotSaved,
              #              RecordNotUnique,
              #              Rollback,
              #              SerializationTypeMismatch,
              #              StatementInvalid,
              #              UnknownAttributeError,
              #              ConnectionBad (PostgreSQL-specific),
              #              SocketError,
              #              StandardError,
              #              Error]
----

=== What else *could* it do?

absolutely anything:

[source, ruby]
----
class Order < ApplicationRecord
  # Associations
  belongs_to :customer
  has_many :order_items
  has_many :payments

  # Callbacks
  before_save :set_defaults, :apply_discounts, :calculate_total, if: :new_record?
  before_save :adjust_inventory
  before_save :check_order_limits, if: :bulk_order?
  after_save :notify_customer
  after_save :generate_invoice, if: :paid?
  after_save :trigger_fulfillment_process, if: :ready_for_fulfillment?
  after_save :update_customer_statistics

  # Validations
  validates :customer_id, presence: true
  validates :status, inclusion: { in: %w[pending paid shipped completed canceled] }

  # Custom Callbacks
  before_validation :sanitize_data, on: :create
  after_commit :log_order_change, on: %i[create update]
end
----

== Building the Core
- A document of what the business problem does.
- When developing, I'm *only* thinking about the domain problem.

=== An example flow

[source, ruby]
----
class ReceivePurchaseOrder < ServiceObject
  def call(purchase_order:, recipient_id:, received_on:)
    receipt_details = ReceiptDetails.new(recipient_id:, received_on:)

    updated_purchase_order = purchase_order.receive(receipt_details)

    # Return a command to store the updated purchase order
    Success([Commands::UpdatePurchaseOrder.new(updated_purchase_order),
             Commands::IncrementRawStock.new(bean_id: updated_purchase_order.bean_id,
                                             g: updated_purchase_order.g)])
  end
end
----

=== The Command

The name is a 'decision', and the data is what the shell needs to apply that decision. Nothing else.

[source, ruby]
----
class IncrementRawStock
  attr_reader :bean_id, :g

  include Dry::Equalizer(:bean_id, :g)

  def initialize(bean_id:, g:)
    @bean_id = bean_id
    @g = g
  end
end
----

[source, ruby]
----
# same thing
[:increment_raw_stock, { bean_id: 1, g: 1000 }]
----

=== Give me valid data, or give me death
The core expects whatever's calling it to already give it valid data types. This means no nil guards, or type checks,
we're just focused on the problem:

[source, ruby]
----
class OrderItem < Dry::Struct
  attribute :price, Types::Money
  attribute :product_name, Types::String
  attribute :status, Types::Symbol
  attribute :bean_mixes, Types::Array.of(Values::BeanMix)
  attribute :roast_type_id, Types::Symbol
end
----


=== Two types of validation 

- This reveals the difference between *business validation* and *data validation*

e.g. Product price must be a decimal is data validation. A minimum price of $10.00 is business validation.

=== Testing
+ There isn't a single mock or stub in the core when it's tested, they're all just objects, there's nothing to mock!

+ The 'unit test' isn't each file, most of them don't really *do* anything other than house data. We unit test the *Flow*, which has been designed to map to a real-world person's goal:

+ The data is valid by assumption, nothing to test there.

[source]
----
 ┌───┐      ┌────────────────────────────────┐       ┌───┐
 │I/O│────► │Business Logic / Decision Making│─────► │I/O│
 └───┘      └────────────────────────────────┘       └───┘
            |────────────────────────────────|
                      UNIT TEST THIS
----


== The Commands I stole from Elm

Elm is a functional language that has a very strong opinion about how to handle side effects. It's called the 'Command Pattern'.

[source]
----
 ┌────────┐
 │  MODEL │◄─────────┐
 └────────┘          │
      │              │
      ▼              │
 ┌──────────┐        │
 │    VIEW  │        │
 │  (model) │        │
 └──────────┘        │
       │             │
       ▼             │
 ┌────────────────┐  │
 │    UPDATE      │  │
 │(model, Command)├──┘
 └────────────────┘
----

== The 'I/O' layer outside of Rails
An absolute hell hole.

=== Me using the most popular SQL management gem to write some data
[source,ruby]
----
   
class OrderRepository
  include Dry::Monads[:result]
  include Dry::Monads::Do.for(:create, :find)
  def initialize(container = DB_CONTAINER)
    @orders = container.relations[:orders]
  end

  def create(order)
    order_data = {
      id: order.id,
      customer_id: order.customer.id,
      shipping_address_json: order.shipping_address.to_h.to_json,
      billing_address_json: order.billing_address.to_h.to_json,
      status: order.status.to_s,
      created_at: Time.now
    }
    @orders.changeset(:create, order_data).commit

    order.items.each do |item|
      OrderItemRepository.new.create_for_order_id(order.id, item)
    end

    Success(order)
  rescue StandardError => e
    Failure(e.message)
  end

  def find(order_id)
    order_data = @orders.by_pk(order_id).combine(:order_items).one!
    customer = yield CustomerRepository.new.find(order_data[:customer_id])

    shipping_address_data = JSON.parse(order_data[:shipping_address_json])
    billing_address_data = JSON.parse(order_data[:billing_address_json])

    order = Order.new(order_data.merge(
                        customer:,
                        shipping_address: Address.new(shipping_address_data),
                        billing_address: Address.new(billing_address_data),
                        items: map_items_to_entities(order_data[:order_items])
                      ))

    Success(order)
  rescue StandardError => e
    Failure(e.message)
  end

  private

  def map_items_to_entities(items_data)
    items_data.map do |item_data|
      OrderItem.new(item_data)
    end
  end
end
----
   
== The Lego Problem
Composability with Dry Monads and Dry Transactions.

== The best idea I've got for now
[source]
----
 ┌────────┐
 │  MODEL │◄─────────┐ | The Rails DB
 └────────┘          │
      │              │
      ▼              │
 ┌──────────┐        │
 │    VIEW  │        │
 │  (model) │        │ | The Rails views, controllers, routing
 └──────────┘        │
       │             │
       ▼             │
 ┌────────────────┐  │
 │    UPDATE      │  │
 │(model, Command)├──┘ | The functional core, returning commands and some modified objects for Rails to save.
 └────────────────┘
----
